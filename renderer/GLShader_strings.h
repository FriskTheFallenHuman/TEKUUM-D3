/* OpenGL GLSL shaders, as static data buffers for release mode builds */
/* DO NOT EDIT - this file is autogenerated - see BUILD.txt */
/* To regenerate this file, run: premake4 embed */ 

typedef struct {
	char *name;
	char *shaderText;
} glslShaderDef_t;

static const glslShaderDef_t glsl_shaders[] = {
{ "forwardLighting_vs", 	"/*\nCopyright (C) 2009-2012 Robert Beckebans\nAll Rights Reserved.\n*/\n// attribute vec4		va_Position;\nattribute vec4		va_TexCoord0;\nattribute vec3		va_Tangent;\nattribute vec3		va_Bitangent;\nattribute vec3		va_Normal;\n// attribute vec4		va_Color;\nuniform vec3		u_LightOrigin;\nuniform vec3		u_ViewOrigin;\nuniform vec4		u_LightProjectS;\nuniform vec4		u_LightProjectT;\nuniform vec4		u_LightProjectQ;\nuniform vec4		u_LightFalloffS;\nuniform vec4		u_DiffuseMatrixS;\nuniform vec4		u_DiffuseMatrixT;\nuniform vec4		u_BumpMatrixS;\nuniform vec4		u_BumpMatrixT;\nuniform vec4		u_SpecularMatrixS;\nuniform vec4		u_SpecularMatrixT;\nuniform vec4		u_ColorModulate;\nuniform vec4		u_Color;\n/*\n#if defined(AMBIENT_ONLY)\nuniform vec3		u_ModelMatrix0		: ENV20,\nuniform vec3		modelMatrix1		: ENV21,\nuniform vec3		modelMatrix2		: ENV22,\n#endif\n*/\nvarying vec3		var_LightVector;\n#if defined(USE_NORMAL_MAPPING)\nvarying vec2		var_BumpST;\n#else\nvarying vec3		var_Normal;\n#endif\nvarying vec2		var_LightFalloff;\nvarying "
	"vec3		var_LightProjection;\nvarying vec2		var_DiffuseST;\nvarying vec2		var_SpecularST;\nvarying vec3		var_HalfAngleVector;\nvarying vec4		var_PrimaryColor;\nvoid main()\n{\n	// transform vertex position into homogenous clip-space\n	gl_Position = ftransform();\n	// light falloff texgen\n	var_LightFalloff.x = dot(u_LightFalloffS, gl_Vertex);\n	var_LightFalloff.y = 0.5;\n  \n	// light projection texgen\n	// var_LightProjection = mat4x3(u_LightProjectS, u_LightProjectT, u_LightProjectQ) * gl_Vertex;\n	var_LightProjection.s = dot(u_LightProjectS, gl_Vertex);\n	var_LightProjection.t = dot(u_LightProjectT, gl_Vertex);\n	var_LightProjection.z = dot(u_LightProjectQ, gl_Vertex);\n	// diffuse map texgen\n	// var_DiffuseST = mat4x2(u_DiffuseMatrixS, u_DiffuseMatrixT) * va_TexCoord0;\n	var_DiffuseST.s = dot(u_DiffuseMatrixS, va_TexCoord0);\n	var_DiffuseST.t = dot(u_DiffuseMatrixT, va_TexCoord0);\n	// specular map texgen\n	// var_SpecularST = mat4x2(u_SpecularMatrixS, u_SpecularMatrixT) * va_TexCoord0;\n	var_SpecularST.s ="
	" dot(u_SpecularMatrixS, va_TexCoord0);\n	var_SpecularST.t = dot(u_SpecularMatrixT, va_TexCoord0);\n	// light and halfangle vectors\n	vec3 L = normalize(u_LightOrigin.xyz - gl_Vertex.xyz);\n	vec3 V = normalize(u_ViewOrigin.xyz - gl_Vertex.xyz);\n	vec3 H = normalize(L) + normalize(V);\n	\n#if defined(USE_NORMAL_MAPPING)\n	// normal map texgen\n	// var_BumpST = mat4x2(u_BumpMatrixS, u_BumpMatrixT) * va_TexCoord0;\n	var_BumpST.s = dot(u_BumpMatrixS, va_TexCoord0);\n	var_BumpST.t = dot(u_BumpMatrixT, va_TexCoord0);\n	// rotate L and H into tangent space\n	\n	// mat3 TBN = mat3(normalize(va_Tangent), normalize(va_Bitangent), normalize(va_Normal));\n#if 0\n	mat3 TBN = transpose(mat3(va_Tangent, va_Bitangent, va_Normal));\n#else\n	mat3 TBN = mat3(va_Tangent.x, va_Bitangent.x, va_Normal.x,\n					va_Tangent.y, va_Bitangent.y, va_Normal.y,\n					va_Tangent.z, va_Bitangent.z, va_Normal.z);\n#endif\n	\n	var_LightVector = TBN * L;\n	var_HalfAngleVector = TBN * H;\n#else\n	// regular blinn-phong lighting can be done in objec"
	"t space\n	var_Normal = va_Normal;\n	var_LightVector = L;\n	var_HalfAngleVector = H;\n#endif\n	// primary color\n// #if defined(DOOM3)\n	var_PrimaryColor = gl_Color * u_ColorModulate + u_Color;\n// #else\n	// this was simplified in Quake 4\n// 	var_PrimaryColor = (color * u_ColorModulate.x) + u_ColorModulate.y;\n// #endif\n}\n"},

{ "forwardLighting_fs", 	"/*\nCopyright (C) 2009-2012 Robert Beckebans\nAll Rights Reserved.\n*/\nuniform samplerCube u_NormalCubeMapImage;	// TEXUNIT0\nuniform sampler2D   u_NormalImage; 			// TEXUNIT1\nuniform sampler2D   u_LightFalloffImage;	// TEXUNIT2\nuniform sampler2D   u_LightImage;			// TEXUNIT3\nuniform sampler2D   u_DiffuseImage;			// TEXUNIT4\nuniform sampler2D   u_SpecularImage;		// TEXUNIT5\n// uniform sampler2D   u_SpecularTableImage;	// TEXUNIT6\nuniform vec4		u_DiffuseColor;\nuniform vec4		u_SpecularColor;\nvarying vec3		var_LightVector;\n#if defined(USE_NORMAL_MAPPING)\nvarying vec2		var_BumpST;\n#else\nvarying vec3		var_Normal;\n#endif\nvarying vec2		var_LightFalloff;\nvarying vec3		var_LightProjection;\nvarying vec2		var_DiffuseST;\nvarying vec2		var_SpecularST;\nvarying vec3		var_HalfAngleVector;\nvarying vec4		var_PrimaryColor;\nvoid main()\n{\n#if defined(USE_NORMAL_MAPPING)\n	#if defined(USE_NORMALIZATION_CUBE)\n	vec3 L = textureCube(u_NormalCubeMapImage, var_LightVector).xyz * 2 - 1;\n	vec3 H = textureCube(u_No"
	"rmalCubeMapImage, var_HalfAngleVector).xyz * 2 - 1;\n	vec3 N = texture2D(u_NormalImage, var_BumpST).wyz * 2 - 1;\n	#else\n	vec3 L = normalize(var_LightVector);\n	vec3 H = normalize(var_HalfAngleVector);\n	// NOTE: this is .wyz and not .xyz !!!\n	vec3 N = normalize(2.0 * (texture2D(u_NormalImage, var_BumpST).wyz - 0.5));\n	#endif\n#else\n	vec3 L = normalize(var_LightVector);\n	vec3 H = normalize(var_HalfAngleVector);\n	vec3 N = normalize(var_Normal);\n#endif\n   \n#if defined(HALF_LAMBERT)\n	// http://developer.valvesoftware.com/wiki/Half_Lambert\n	float NdotL = dot(N, L) * 0.5 + 0.5;\n	NdotL *= NdotL;\n#else\n	// traditional very dark Lambert light model used in Doom 3\n	float NdotL = clamp(dot(N, L), 0.0, 1.0);\n#endif\n	vec4 Cd = u_DiffuseColor * texture2D(u_DiffuseImage, var_DiffuseST);\n	float NdotH = clamp(dot(N, H), 0.0, 1.0);\n#if 0 //defined(DOOM3)\n	vec4 spec = u_SpecularColor * texture2D(u_SpecularTableImage, NdotH).x;\n	vec4 Cs = spec * 2 * texture2D(u_SpecularImage, var_SpecularST);\n#else\n	// Bli"
	"nn–Phong shading model\n	vec4 Cs = vec4(2.0) * vec4(texture2D(u_SpecularImage, var_SpecularST).rgb * pow(NdotH, 16.0), 1.0);\n#endif\n	vec4 Cl = texture2DProj(u_LightImage, var_LightProjection) * texture2D(u_LightFalloffImage, var_LightFalloff);\n	gl_FragColor = var_PrimaryColor * Cl * NdotL * (Cd + Cs);\n	// gl_FragColor = Cl * NdotL * (Cd + Cs);\n	// gl_FragColor = vec4(NdotL);\n	// gl_FragColor = Cd;\n}\n"},

{ "shadowVolume_vs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\n// attribute vec4		va_Position;\n// attribute vec4		va_Color;\nuniform vec3		u_LightOrigin;\n// uniform mat4		u_ModelViewProjectionMatrix;\nvarying vec4		var_Color;\nvoid	main()\n{\n	if(gl_Vertex.w == 1.0)\n	{\n		// transform vertex position into homogenous clip-space\n		gl_Position = ftransform();\n	}\n	else\n	{\n		// project vertex position to infinity\n		vec4 vertex = vec4((gl_Vertex.xyz - u_LightOrigin), 0.0);\n		gl_Position	= gl_ModelViewProjectionMatrix * vertex;\n	}\n	\n	// assign color\n	var_Color = gl_Color;\n}"},

{ "shadowVolume_fs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nvarying vec4		var_Color;\nvoid	main()\n{\n	gl_FragColor = var_Color;\n}"},

{0, 0},

};
